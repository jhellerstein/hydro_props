## DBSP is pretty simple for us to emulate
This assumes we have an Abelian group based on + (commutative, with inverses).
- _Differentiate_ in DBSP takes a cumulative source and produce a delta output. It is implemented as:
```rust
in = mod -> tee();
lastR = R -> defer_tick();
in -> [pos]dR;
lastR -> [neg]dR;
dR = difference() -> mod;
```
More ideally, `difference()` is really `reduce(sum)` on inverse values:
```rust
in = mod -> tee();
lastR = R -> defer_tick();
in -> dR;
lastR -> map(|x| inverse(x)) -> dR;
dR = union() -> reduce(sum) -> mod;
```

- _Integrate_ is essentially
```rust
mod -> reduce(sum) -> mod
```
for the group operator `sum`.

- The key rewriting axioms we want to use are in Proposition 3.2 of the [DBSP arXiv paper](https://arxiv.org/abs/2203.16684).
With these we can turn a subgraph whose edges are of type Abelian group into a fully differential stream. 

With this it's fairly natural to implement, for example, multiset or set semantics. E.g.
we should be able to do all of datalog/dedalus this way. The DBSP paper gives examples, but it's all
fairly textbook. The trickiest detail is the bilinear operators like join that get rewritten as
$R \times S = dR \times dS \cup dR \times S \cup R \times dS$. We've tested this and it works in Hydroflow today.

## Note: delta vs cumulative is orthogonal to tick vs static
We can have deltas or cumulatives within a tick or across ticks.

## What if we have edges that are not Abelian Groups?
These edges need to work with cumulatives since we cant implement `inverse`. Hence we need to support
flows that are a mix of deltas and cumulatives in the runtime.

## Current concerns
- To save work, can we passing cumulatives by reference rather than by value?
- Our current scheduling sometimes wants to reference unchanged upstream cumulatives for binary ops
  with `static` semantics implemented via `persist` ops.
  Example in current
  (non-DBSP-emulating) hydroflow is
  ```rust
   left = R -> persist() -> tee();
   right = S -> persist() -> tee();
   left -> ... <otherstuff>;
   right -> ... <moreotherstuff>;

   left -> [0]join::<'tick>;
   right -> filter(...) -> [1]join;
   ```
  The interesting bit is the last line -- when we get a new `left` tuple, we need to join against all the
  `right` tuples so we want to "replay" the `persist()` on `S` (the second line).

Questions:
1. is this even worth supporting, or does a `persist()` need to be at the input to the join in all cases?
    - If we require/inject a `persist` for any such join, would redundant `persist`s be easy to "rewrite away"
    - What are the rewriting rules for `persist` -- i.e. what does it commute with?
2. For streams that are Abelian groups, does the bilinear delta rewrite above make this problem go away?
    - Note: even if this is true, we need to solve the problem for other subgraphs that aren't delta-rewritable!
3. How would we rethink this example in terms of cumulative and delta edge types?\
    - Version 1: assume this is a (differentiable) relational example (which it is, given the use of `join`)
    - Version 2: assume it's a non-differentiable, non-Abelian-group latticeflow example. Is scheduling still hard?

Version 2 (all inputs are cumulative type):
```rust
   cumu_left = R -> lattice_merge::<'static> -> tee();
   cumu_right = S -> lattice_merge::<'static> -> tee();
   cumu_left -> ... <otherstuff>;
   cumu_right -> ... <moreotherstuff>;

   cumu_left -> [0]the_join;
   cumu_right -> filter(...) -> [1]the_join;
   join = join()::<'tick>;
```
Here it's clear we won't have sharing: we can't use the cumulative from `right` in the join, since `filter` computes 
a different cumulative and (in general) we can't "peek" inside that cumulative and extract a "sublattice"
corresponding to filter. Hence `filter` will pass a different cumulative to `join` -- whether it's by value or by ref,
the point is that it is passed on a single edge without sharing.

From here, if the above *was* an Abelian group, we'd apply the DBSP chain rule to differentiate it from the outside in.
And it would look like the following:
```rust
   left = R -> delta() -> tee();
   right = S -> delta() -> tee();
   left -> ... <otherstuff>;
   right -> ... <moreotherstuff>;

   left -> [0]the_join;
   right -> filter(...) -> [1]the_join;
   the_join = delta_join_static;
```
where `delta_join_tick` is the macro for $dR \times dS \cup dR \times S \cup R \times dS$. Note that we're applying `delta` to `R` and `S` even thought we removed the `lattice_merge`: this ensures that if inbound data is redundant, we differentiate it. 
