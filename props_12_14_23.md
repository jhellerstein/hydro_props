## DBSP is pretty simple for us to emulate
This assumes we have an Abelian group based on + (commutative, with inverses).
- _Differentiate_ in DBSP takes a cumulative source and produce a delta output. It is implemented as:
```rust
in = mod -> tee();
lastR = R -> defer_tick();
in -> [pos]dR;
lastR -> [neg]dR;
dR = difference() -> mod;
```
More ideally, `difference()` is really `reduce(sum)` on inverse values:
```rust
in = mod -> tee();
lastR = R -> defer_tick();
in -> dR;
lastR -> map(|x| inverse(x)) -> dR;
dR = union() -> reduce(sum) -> mod;
```

- _Integrate_ is essentially
```rust
mod -> reduce(sum) -> mod
```
for the group operator `sum`.

- The key rewriting axioms we want to use are in Proposition 3.2 of the [DBSP arXiv paper](https://arxiv.org/abs/2203.16684).
With these we can turn a subgraph whose edges are of type Abelian group into a fully differential stream. 

With this it's fairly natural to implement, for example, multiset or set semantics. E.g.
we should be able to do all of datalog/dedalus this way. The DBSP paper gives examples, but it's all
fairly textbook. The trickiest detail is the bilinear operators like join that get rewritten as
$R \times S = dR \times dS \cup dR \times S \cup R \times dS$. We've tested this and it works in Hydroflow today.

## Note: delta vs cumulative is orthogonal to tick vs static
We can have deltas or cumulatives within a tick or across ticks.

## What if we have edges that are not Abelian Groups?
These edges need to work with cumulatives since we cant implement `inverse`. Hence we need to support
flows that are a mix of deltas and cumulatives in the runtime.

## Current concerns
- To save work, can we passing cumulatives by reference rather than by value?
- Our current scheduling sometimes wants to reference unchanged upstream cumulatives for binary ops
  with `static` semantics implemented via `persist` ops.
  Example in current
  (non-DBSP-emulating) hydroflow is
  ```rust
   left = R -> persist() -> tee();
   right = S -> persist() -> tee();
   left -> ... <otherstuff>;
   right -> ... <moreotherstuff>;

   left -> [0]join::<'tick>;
   right -> filter(...) -> [1]join;
   ```
  The interesting bit is the last line -- when we get a new `left` tuple, we need to join against all the
  `right` tuples so we want to "replay" the `persist()` on `S` (the second line).

Questions:
1. is this even worth supporting, or does a `persist()` need to be at the input to the join in all cases?
    - If we require/inject a `persist` for any such join, would redundant `persist`s be easy to "rewrite away"
    - What are the rewriting rules for `persist` -- i.e. what does it commute with?
2. For streams that are Abelian groups, does the bilinear delta rewrite above make this problem go away?
    - Note: even if this is true, we need to solve the problem for other subgraphs that aren't delta-rewritable!
3. How would we rethink this example in terms of cumulative and delta edge types?
    - Version 1: assume this is a (differentiable) relational example (which it is, given the use of `join`)
    - Version 2: assume it's a non-differentiable, non-Abelian-group latticeflow example. Is scheduling still hard?

Version 2 (all inputs are cumulative type, assume `'tick` semantics so we don't have to think about persistence over time yet):
```rust
   cumu_left = R -> tee();
   cumu_right = S -> tee();
   cumu_left -> ... <otherstuff>;
   cumu_right -> ... <moreotherstuff>;

   cumu_left -> [0]the_join;
   cumu_right -> filter(...) -> [1]the_join;
   join = join()::<'tick>;
```
Here it's clear we won't have sharing: we can't use the cumulative from `right` in the join, since `filter` computes 
a different cumulative and (in general) we can't "peek" inside that cumulative and extract a "sublattice"
corresponding to filter. Hence `filter` will pass a different cumulative to `join` -- whether it's by value or by ref,
the point is that it is passed on a single edge without sharing.

From here, if the above *was* an Abelian group, we'd apply the DBSP chain rule to differentiate it from the outside in.
And it would look like the following:
```rust
   dleft = R -> delta() -> tee();
   dright = S -> delta() -> tee();
   dleft -> ... <otherstuff>;
   dright -> ... <moreotherstuff>;

   dleft -> [0]the_join;
   dright -> filter(...) -> [1]the_join;
   the_join = delta_join_tick;
```
where `delta_join_tick` is the macro for $dR \times dS \cup dR \times S \cup R \times dS$.

Here the only accumulation/persistence required is inside the join macro, where we materialize $R$ and $S$.

## Additional Thoughts, 12/7
1. DBSP assumes you have an Abelian group, so you have an identity item $0$ and every item $s$ in the domain has an inverse such that $s + s^{-1} = 0$. Let’s assume this is a common case for us, but not universal (DBSP reviews tricks to get relational semantics using this, for example). So we should exploit DBSP tricks when we can, but we shouldn’t count on them. Said differently, we probably want a mixed algebra model, that annotates graph edges with algebraic properties, and we only exploit those that we can where we can. This might push us into interesting new territory.
2. The temporal model of DBSP aligns nicely with that of Hydroflow (inherited from Dedalus): totally-ordered time, and the ability to “compare” across 1 time offset.
    - Dedalus/Hydroflow allows us to defer updates to one tick in the future.
    - DBSP has a $z^{-1}$ operator that lets you examine the state of its input one tick in the past.
    - These are interchangeable .. in Dedalus if we want to implement $z^{-1}$ for a relation $r$ we define an IDB for it:  `z_r@t+1 :- r`  (or in Hydroflow a variable like `z_r = r -> defer_tick()`).
3. As a result of (2) the rewrites in the DBSP paper for delta management port directly to Hydroflow. @Chris Douglas and I have implementations of delta-rewritten join and distinct in a fork of the Hydroflow repo. The other trickyish example in the DBSP arxiv paper is recursion, datalog-style, which I’ll do next. I think it’ll also be direct.
    - With these examples in place, the next step is a general proof. There is a nice small proposition in the DBSP paper regarding the key rewrites that we should port to Hydroflow-over-Abelian-groups
    - With that done we should ensure that these rewrites cause no harm for parts of a Hydroflow program that aren’t over Abelian Groups.
4. In my mind there’s still a disconnect between the Hydroflow notions of persistence and DBSP’s _differentiation_ vs _integration_ (the word "delta" is used in both so I’ll try to use _differential_ when discussing DBSP). One thing I toyed with was to look at all combinations of Hydroflow’s `'static` vs `'tick` with DBSP’s _differential_ vs _integral_, but not all combinatios make sense. The definition of _differential_ in DBSP is in terms of the $z{^-1}$ operator, which “subtracts” the last tick from the current tick --- so you can’t create differentials within a single timestep.  
    - One hypothesis is DBSP only can express `'static` semantics anyhow, so we shouldn’t hope to mix DBSP reasoning with parts of a Hydroflow graph that use `'tick`. 
    - Or maybe the hypothesis is false, but it’s just awkward to get `'tick` semantics in DBSP because it is “persistent by default”, where Dedalus is “ephemeral by default”. If so, we need a DBSP design pattern for “ephemerality circuits” (complementing Dedalus’ “persistence rules”), which at the start of each tick “inverts” (i.e. deletes) all items from the previous tick.
    - Note on the above: to implement inverting "at the start of each tick" in DBSP, we might need to "insert a tick" between each pair to delete `'tick` stuff, and add "persistence rules" to DBSP to get $z^{-1}$ to work after the second tick for those collections that are `'static`.
5. Even if we can implement 'tick semantics in DBSP, I'm _still_ not sure what it could mean to do differential computation "within a tick", and that concerns me a bit as we clearly want to flow large collections along edges within a single tick.
